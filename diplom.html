<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 4.08">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 <style type="text/css"><!--
 .tiny {font-size:30%;}
 .scriptsize {font-size:xx-small;}
 .footnotesize {font-size:x-small;}
 .smaller {font-size:smaller;}
 .small {font-size:small;}
 .normalsize {font-size:medium;}
 .large {font-size:large;}
 .larger {font-size:x-large;}
 .largerstill {font-size:xx-large;}
 .huge {font-size:300%;}
 --></style>

 
<title>[utf8x]</title>

<div class="p"><!----></div>
[utf8x] inputenc


















 [english , russian] babel




  `" 

	
<div align="right">		<b>Алгоритм для раскроя двумерного материала</b><br />
		<i><span class="small">Мельников Вадим Андреевич,<br />Сыткывкарский государственный университет им. Питирима Сорокина,<br />г. Сыктывкар.</span></i>
	</div>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	<b>Аннтоция.</b> Данная сататья посвящена вопросам резки материала на заготовки неправильной формы в двумерном. Были рассмотрены основные вопросы связанные с представлением геометрической информации, методами отыскания оптимальной раскройной последовательности и оптимизацией алгоритма.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	<b>Ключевые слова:</b> раскрой, генетические алгоритмы, двумерное пространство.
	
 <a id="tth_sEc1"></a><h2>
1.&nbsp;&nbsp;Введение в задачу раскроя материала</h2>
	Экономия материала представляет собой сложную и важную проблему, с которой
	часто приходится встречаться на различных производствах, при резке различных материалов на: листы металла, стекла или дерева, трубы, профильный прокат, изделия сложной формы. Для её решения необходимо максимизировать использование материала, из которого вырезаются заготовки, что по сути и является рациональным раскроем материала. Максимизация использования материалов позволяет достичь большой экономии денежных средств.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	На самом деле, задача раскроя является NP-полной даже для прямоугольников. Для
	фигур неправильной формы геометрическая сложность увеличивает количество совершаемых вычислений, поэтому применяются различные эвристические методы решения задачи.
	
 <a id="tth_sEc2"></a><h2>
2.&nbsp;&nbsp;Основные характеристика задач раскроя</h2>
	Прежде чем приступать к рассмотрению алгоритмов решения задачи раскроя, следует рассмотреть характеристики, влияющие на то, как будет выглядеть итоговый алгоритм решения. В статье [<a href="#Dyckhoff" id="CITEDyckhoff" class="tth_citation">1</a>] Harald Dyckhoff приводит достаточно полное описание характеристик задач раскроя.
	
     <a id="tth_sEc2.1"></a><h3>
2.1.&nbsp;&nbsp;Пространственные характеристики</h3>
	Основная характеристика раскроя - количество измерений:
	
<ul>
<li> раскрой в одномерном пространстве;
<div class="p"><!----></div>
</li>

<li> раскрой в двумерном пространстве;
<div class="p"><!----></div>
</li>

<li> раскрой в трёхмерном пространстве.
<div class="p"><!----></div>
</li>
</ul>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Например загрузка поддонов является задачей в двумерном пространстве. В отличие от 	задач в двух и более измерениях, задача в одномерном пространстве имеет явное решение. Достаточно подробно данная задача описывается в книге [<a href="#Cantorovich" id="CITECantorovich" class="tth_citation">2</a>] Канторовича-Залгаллера - &lt;&lt;Рациональный раскрой промышленных материалов&#62;&#62;. Так же в данной книге можно найти методы решения задач двумерного раскроя для случая прямоугольнных заготовок.
	
     <a id="tth_sEc2.2"></a><h3>
2.2.&nbsp;&nbsp;Количественные характеристики</h3>
	Другая важная характеристика - количественная. В задаче раскроя необходимо
	некоторым образом измерять количественные и качественные характеристики фигур.
	Например, площадь, длина и ширина фигур. Или количество уже расположенных фигур. Тут можно рассмотреть два варианта:
	
<ul>
<li> дискретное измерение с помощью, например, натуральных и целых чисел;
<div class="p"><!----></div>
</li>

<li> дробное измерение на основе вещественных чисел.
<div class="p"><!----></div>
</li>
</ul>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Первый вариант позволяет нам подсчитывать количество изделий, уже расположенных
	на материале, а с помощью второго можно измерять различные характеристики фигур, 	такие как площадь, длина и ширина.
	
     <a id="tth_sEc2.3"></a><h3>
2.3.&nbsp;&nbsp;Геометрические характеристики</h3>
	Не малую роль играют в раскрое сами фигуры, которые необходимо расположить
	на плоскости. В пространстве фигуры однозначно определяются с помощью следующих
	свойств:
	
<ul>
<li> формой;
<div class="p"><!----></div>
</li>

<li> размером;
<div class="p"><!----></div>
</li>

<li> ориентацией;
<div class="p"><!----></div>
</li>

<li> правильной или неправильной формой.
<div class="p"><!----></div>
</li>
</ul>
	
     <a id="tth_sEc2.4"></a><h3>
2.4.&nbsp;&nbsp;Характеристики по ограничениям на результат</h3>
	По ограничениям на результат можно выделить четыре основные группы:
	
<ul>
<li>  минимальное расстояние между объектами;
<div class="p"><!----></div>
</li>

<li> ориентация фигур относительно друг друга;
<div class="p"><!----></div>
</li>

<li> ограничение на количество фигур;
<div class="p"><!----></div>
</li>

<li> ограничение на количество совершаемых &lt;&lt;резов&#62;&#62;.
<div class="p"><!----></div>
</li>
</ul>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Автор выделяет ещё несколько групп по различным признакам, но данные являются
	основными.
	
 <a id="tth_sEc3"></a><h2>
3.&nbsp;&nbsp;Постановка задачи</h2>
	Прежде чем переходить к алгоритмам, применяемым для решения задачи раскроя, следует рассмотреть математическую постановку задачи. Задача ставится по аналогии с задачей раскроя в одномерном пространстве [<a href="#Nikitenkov" id="CITENikitenkov" class="tth_citation">3</a>].
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Имеется сырьё площади S, на котором неоьходимо расставить заготовки M различных типов. Площади заготовок задаются вектором s[M], а количество заготовок каждого типа задаётся вектором b[M].
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Пусть матрица A[M, N] - целочисленная матрица всех потенциально возможных способов раскроя одной единицы сырья, &#124;N&#124;=n - число таких способов. Потенциально возможный способ раскроя - столбец матрицы A[M, j], j &#8712; 1:N, удовлетворяющий условию:
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
s[M]&#183;A[M,j] &#8804; S.</td></tr></table>
</td><td width="1%">(1)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Пусть x[M] - искомый вектор, являющийся некоторым столбцом матрицы A. Тогда задача минимизации суммарных отходов сырья запишится следующим образом:
																		
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
f = S &#8722; x<sup>T</sup>[M]&#183;s[M] &#8594; </td><td nowrap="nowrap" align="center">
min<br />
</td><td nowrap="nowrap">x[M]  &#8804; b[M]S &#8722; x<sup>T</sup>[M]&#183;s[M]  &#8805; 0 x[M]  &#8805; 0</td></tr></table>
</td><td width="1%">(2)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Важной особенностью задачи раскроя в двумерном пространстве является то, что не каждый столбец матрицы A удовлетворяющий заданным условиям является реальным решением. Данный факт объясняется произвольностью форм заготовок, поэтому нельзя одназначно утверждать, что если заданные условия выполнены для некоторой последовательности, то эта последовательность является решением.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Из сказанного выше следует нелинейность задачи и то, что решение задачи может быть не только на границе многогранника, заданного условиями. Таким образом, необходимо отыскивать последовательность с помощью некоторого &lt;&lt;оптимизированного&#62;&#62; перебора. Также заданные условия никак не определяют координаты расстановки заготовок на единице сырья. Методы для решения данныъ проблем и будут описываться в дальнейшем. 
	
 <a id="tth_sEc4"></a><h2>
4.&nbsp;&nbsp;Методы представления фигур для раскроя</h2>
	Самым видимым атрибутом задач раскроя и тем, с чем сразу сталкиваются исследователи в данной области - геометрическое представление фигур. Решение о том, 	как представлять фигуры, оказывает решающее значение на дальнейшую разработку системы.
	
     <a id="tth_sEc4.1"></a><h3>
4.1.&nbsp;&nbsp;Методы перемещения фигур</h3>
	Прежде чем перейти к рассмотрению методов представления фигур, следует осветить важный вопрос, обычно опускаемый в литературе связанной с раскроем: &lt;&lt;Каким 	образом перемещать фигуры относительно друг друга?&#62;&#62;.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Предположим, что мы уже некоторым образом расположили первую фигуру. Она распологается всегда в левом нижнем углу, как на рис. <a href="#first_placed">1</a>. Для удобства, границы контейра изображать не будем. Условимся, что вторая фигура в конечном расположении будет закрашена серым цветом.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Самый первый метод, который будет интуитивно понятен всем — &lt;&lt;лестничный&#62;&#62; или же	&lt;&lt;тетрисный&#62;&#62;. Его суть заключается в том, что мы двигаем фигуру вниз до первого столкно	вения с другой, потом также влево, потом опять вниз, и так далее пока фигура не перестанет смещаться. Рассмотрим на примере, как &lt;&lt;тетрисный&#62;&#62; способ расположит следующую фигуру. На рис. <a href="#second_tetris">2</a> видно, что фигура перемещается слева направо с некоторым шагом по оси x и в итоге находит углебление внутри другой фигуры.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Более сложный метод — «метод сквозного прохода». Его основная идея заключается в том, что фигуру просто перемещают сквозь остальные и ищут подходящее ей место. Как 	видно на рис. <a href="#second_through">3</a>, данный метод нашёл закрытую полость, до которой предыдущий способ дойти не смог.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Самый сложный метод - движение вдоль контура. Под контуром, в данном случае,
	подразумевается обновлемый контейнер. Изначально имеется некоторый контур пустого контейнера, затем в него добавляются одна за одной фигуры, и контур после расположения каждой из них изменяется. Таким образом, фигура движется вдоль контура контейнера, при нахождении подходящего места необходимо обновить контур с учетом расположения новой фигуры. На данный момент этот метод будет оставлен без особого внимания. Для его реализации необходимо создать цепь (растровую или же векторную) вдоль которой будет перемещаться фигура. Большую сложность, представляет в данном случае вопрос о выборе точки, относительно которой идёт движение.
	
     <a id="tth_sEc4.2"></a><h3>
4.2.&nbsp;&nbsp;Представление фигур в виде многоугольников</h3>
	Представление фигур в виде многоугольников даёт хорошую точность аппроксимации. В таком представлении объем информации пропорционален числу вершин и не зависит от размера фигуры. Полигональное представление является первичным для фигур, а на его основе уже можно построить растровое представление, которое будет описано ниже.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Полигональный метод хоть и даёт высокую точность представления, но имеет очень высокую вычислительную сложность - <span class="roman">O</span>(e<sup>n</sup>), где n - число вершин фигуры.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Для того, чтобы проверить нет ли пересечений между какими-либо фигурами нужно
	выполнить следующий набор тестов [<a href="#Benell_Olivera" id="CITEBenell_Olivera" class="tth_citation">4</a>]:
	
<ol type="1">
<li> Проверить пересекаются ли описывающие прямоугольники фигур, если нет, то и фигуры не пересекаются, иначе перейти к следующему тесту.
<div class="p"><!----></div>
</li>

<li> Для каждой пары рёбер проверить, пересекаются ли их описывающие прямоугольники.
<div class="p"><!----></div>
</li>

<li> Проверить, пересекаются ли рёбра.
<div class="p"><!----></div>
</li>

<li> Проверить, лежат ли какие-либо вершины одного полигона, внутри другого.
<div class="p"><!----></div>
</li>
</ol>
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Проверка на пересечения текущей фигуры с ранее расположенными может выполняться различными способами. Первый вариант - через уравнение прямой с угловым коэффициентом. Этот метод для данной задачи будет излишним, ведь кроме проверки на пересечение двух отрезков, будут найдены точка пересечения и угловой коэффициент k данной прямой. Также придётся проверять специальные случаи, когда прямые параллельны, когда они направлены вертикально вверх. Лучше использовать метод проверки на основе псевдоскалярного произведения, ведь тогда сильно снизится вычислительная нагрузка. Данный метод подробно рассматривается в задачах вычислительной геометрии.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Для перемещения фигуры подходят только алгоритмы &lt;&lt;тетрисного&#62;&#62; движения. Применять «сквозное движение» мы не можем, так, как тогда придется постоянно проверять, не попала ли она внутрь другой, что в случае многоугольников сделать достаточно сложно. Для этого необходимо применять метод &lt;&lt;трассировки луча&#62;&#62; или приближённо считать комплексный интеграл, пользуясь интегральной формулой Коши.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Алгоритмы с представлением фигур в виде полигонов хорошо подходят для прямоугольников и несложных многоугольников с числом вершин до сотни. Для более сложных сильно возрастает время вычисления пересечений.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Проблема данного метода состоит в сложности обработки контура. Построить эквидистантный (равноудалённый во всех точках от исходного) контур, чтобы задать зазор - не
	такая уж лёгкая задача. Отделить внешний контур от внутренних тоже несколько сложнее,
	ведь контур может состоять из нескольких раздельных кривых, пусть и образующих в
	сумме одну замкнутую кривую.
	
     <a id="tth_sEc4.3"></a><h3>
4.3.&nbsp;&nbsp;Представление фигур в виде растровых матриц</h3>
	Растровый метод, позволяет упростить геометрическую сложность фигуры и без дополнительных оптимизаций снизить сложность вычислений до <span class="roman">O</span>(n<sup>2</sup>).
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Растровые методы предлагают разделить непрерывный раскройный лист на дискретные части, упрощая сложную геометрическую информацию до представления матрицей. Под матрицей будем понимать некоторое представление растра, в котором отмечены занятые и свободные места. Различные авторы предлагают различные методы представления.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Самый простой метод представления - это 1 для занятого деталью места и 0 для свободного. Раскраиваемый материал в данном случае представляется аналогично. На рис. <a href="#first_rastr">5</a>
	можно увидеть первичный вариант растрового представления [<a href="#Benell_Olivera" class="tth_citeref">4</a>]. В данном случае занятые области отмечены серым цветом.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Растровый способ не является первичным, он строится из фигуры, представленной многоугольником.
	Поэтому нельзя сразу говорить какие места заняты, а какие нет, ведь не входе имеется простое наложение многоугольника не растровую матрицу, что можно увидеть на рис. <a href="#fig_on_rastr">6</a>.
	Рассмотрим возможный алгоритм закраски занятых областей:
	
<ol type="1">
<li> На первом шаге имеется исходный многоугольник. Выберем любое его ребро.
<div class="p"><!----></div>
</li>

<li> Так как каждое ребро задается координатами (x<sub>1</sub> , y<sub>1</sub> ) и (x<sub>2</sub> , y<sub>2</sub> ), то на втором шаге можно получить уравнение прямой с угловым коэффициентом, которая содержит данный
		отрезок. Для определённости будем считать, что y<sub>1</sub>  &#8804; y<sub>2</sub>.
<div class="p"><!----></div>
</li>

<li> Зададим множество A={a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n&#8722;1</sub>, a<sub>n</sub>}, где a<sub>0</sub>=y<sub>1</sub>, а a<sub>n</sub> = y<sub>2</sub>. Остальные элементы являются целыми числами из интервала (y<sub>1</sub>, y<sub>2</sub>).
<div class="p"><!----></div>
</li>

<li> Теперь, для каждой пары чисел {a<sub>i</sub>, a<sub>i+1</sub>},&nbsp;i = 0:n&#8722;1, из имеющегося уравнения прямой y=kx+b, вычислим x<sub>i</sub> и x<sub>i+1</sub>.
<div class="p"><!----></div>
</li>

<li> Вычислив, все необходимые координаты, можно отметить занятыми, все клетки на отрезке заданном координатами (x<sub>i</sub>, a<sub>i</sub>),&nbsp;(x<sub>i+1</sub>, a<sub>i</sub>).
<div class="p"><!----></div>
</li>
</ol>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Алгоритм рассматривает переход от отрезка к растру. Для перехода от многоугольника к растру достаточно повторить описанный алгоритм для всех его ребёр. В итоге получится то, что изображено на рис. <a href="#first_rastr">5</a>.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Операция проверки на пересечения с другими фигурами, при текущем расположении в координате (x, y) фигуры с шириной равной w и высотой h, не требует никаких сложных действий. Производится простое суммирование по следующей формуле:
			<a id="simple_sum">
</a>			
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
S = </td><td nowrap="nowrap" align="center">
<small>h</small><!--sup
--><br /><span class="largerstill">&#8721;<br />
</span><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small>w</small><!--sup
--><br /><span class="largerstill">&#8721;<br />
</span><small>j=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
p<sub>i+y, j+x</sub>f<sub>i,j</sub> </td></tr></table>
</td><td width="1%">(3)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	В данном случае, p<sub>i</sub>+y,j+x - значение в матрице раскройной плоскости со смещением на координату (x, y), а f<sub>i</sub>,j - значение в матрице фигуры. В случае если значение S  &gt;  0, то есть пересечение с некоторой фигурой, иначе его нет.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Как видно на рис. <a href="#first_rastr">5</a>, не все области внутри фигуры отмечены как занятые. В таком случае, некоторые фигуры могут попасть внутрь других, что будет являться ошибкой. Данная
	проблема быть решена различными способами. Самый простой способ - &lt;&lt;залить&#62;&#62; всё, что находится внутри внешнего конутура, отбрасывая пустоты внутри фигуры. Такой метод принесёт большие потери материала.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Рассмотрим метод, позволяющий учитывать пустые места внутри фигур. Для начала необходимо отделить внешний контур фигуры:
	
<ol type="1">
<li> Примем за текущую самую левую занятую точку с наименьшей ординатой.
<div class="p"><!----></div>
</li>

<li>  Отметим цифрой 3 (на изображениях будет отмечаться диагональной штриховкой) текущую точку.
<div class="p"><!----></div>
</li>

<li> Рассмотрим всех соседей текущей точки. Если есть соседняя точка, отмеченная цифрой 1, переходим в данную точку и возвращаемся на второй шаг. Если текущая точка - исходная, то закончить алгоритм, иначе повторить текущий шаг.
<div class="p"><!----></div>
</li>
</ol>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Результат работы алгоритма можно увидеть на рис. <a href="#result_contour">7</a>.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	После отделения внешнего контура, необходимо отметить занятым, всё место между внешним контуром и контурами второго уровня. Это можно сделать следующим образом:
	
<ol type="1">
<li> Первым шагом необходимо сохранить точки контура в отдельный массив и отметить их, как свободные на растровой матрице.
<div class="p"><!----></div>
</li>

<li> Далее, выполняется &lt;&lt;заливка&#62;&#62;. В процессе &lt;&lt;заливки&#62;&#62;, свободные клетки отмечаются как временно занятые цифрой 2 (на изображениях будет изображаться перекрёстной штриховкой). Резултат первых двух шагов приведён на рис. <a href="#12fill_result">8</a>.
<div class="p"><!----></div>
</li>

<li><a id="3fill_step">
</a> Третьим шагом инвертируем &lt;&lt;заливку&#62;&#62;. Для этого необходимо все клетки, отмеченные цифрой 2, отметить цифрой 0. Свободные клетки отметить необходимо отметить как временно занятые.
		Занятые клетки незатрагиваются. После этого можно вернуть на растровой матрице контур фигуры. Результат данного шага приведён на рис. <a href="#3fill_result">9</a>.
<div class="p"><!----></div>
</li>

<li> После этого опять выполняется &lt;&lt;заливка&#62;&#62;. Результат четвёртого шага приведён на рис. <a href="#4fill_result">10</a>;
<div class="p"><!----></div>
</li>

<li> Последним шагом опять выполняется инверсия &lt;&lt;заливки&#62;&#62; по тем же правилам, что и на третьем шаге. Результат работы алгоритма приведён на рис. <a href="#fill_result">11</a>.
<div class="p"><!----></div>
</li>
</ol>
	
	
	
	
	
     <a id="tth_sEc4.4"></a><h3>
4.4.&nbsp;&nbsp;Условия корректности данных</h3>
	Для корректности работы описанных выше алгоритмов и некоторых дальнейших выкладок необходимо ввести условия корректности.

<div class="p"><!----></div>
	
<b>&nbsp;&nbsp;</b>
	Фигура является корректной, если выполняются следующие условия:
	
<ol type="1">
<li> Фигура имеет замкнутый внешний контур.
<div class="p"><!----></div>
</li>

<li> Уровень вложенности контуров не более первого. Это означает, что контура могут вкладываться только во внешний контур, то есть если контур является вложенным во внешний, то в него уже не может быть вложен контур.
<div class="p"><!----></div>
</li>

<li> Вложенные контуры не должны иметь пересечений друг с другом.
<div class="p"><!----></div>
</li>

<li> Ни один из контуров не должен иметь самопересечений.
<div class="p"><!----></div>
</li>
</ol> 
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Не соблюдение приведённых выше условий может привести к непредсказуемым результатам работы алгоритма.
	
     <a id="tth_sEc4.5"></a><h3>
4.5.&nbsp;&nbsp;Снижение сложности до линейной</h3>
	Для корректности дальнейших действий, введём условие, что движение фигур по плоскости материала происходит строго построчно. Из данного утверждения следует тот факт, что если фигура пересекает занятое другой фигурой место, то, хотя бы в одной из точек, пересечение будет лежать на контуре текущей фигуры.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Тогда можно снизить сложность поиска пересечений до <span class="roman">O</span>(n), где n&nbsp;- число точек, входящих в контур. Такой способ поиска пересечений является суммированием по следующей формуле:
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
S=</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><span class="largerstill">&#8721;<br />
</span><small>i,j &#8712; &#915;</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
p<sub>i+y,j+x</sub>.</td></tr></table>
</td><td width="1%">(4)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Данная формула аналогична формуле <a href="#simple_sum">3</a>,  но суммирование проходит только по тем точкам (j, i), которые входят во внешний контур &#915;.
	
 <a id="tth_sEc5"></a><h2>
5.&nbsp;&nbsp;Принципы позиционирования фигур</h2>
	Определившись с представлением фигур и методом их перемещения, разработчику необходимо решить, каким образом производить позиционирование. Первое с чего стоит начать - это поворот фигур. Некоторые авторы предлагают применять изменение угла методом дихотомии, что по сути является бинарным поиском. Но тут возникает большая проблема. Бинарный поиск работает на отсортированном множестве, а контур фигуры таковым не является, поэтому поворот следует выполнять просто с дискретным шагом изменения угла.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	После того как фигура уже лежит где-то на плоскости, её положение надо оценить.
	Очень часто применяют принцип левого нижнего угла (ЛН-принцип). Так-как фигуры
	имеют сложный контур, можно предложить следующее улучшение данного метода. Пользуясь тем, что точки входящие контур известны, можно найдём его центр масс по следующей формуле:
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
P<sub>g</sub>=</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><span class="largerstill">&#8721;<br />
</span><small>p &#8712; &#915;</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
P<sub>i</sub>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>n<br /></td><td nowrap="nowrap" align="center">
,</td></tr></table>
</td><td width="1%">(5)</td></tr></table>


	где P<sub>i</sub> - это точка входящая в контур &#915;. Теперь можно не только пытаться расположить
	фигуру максимально влево и вниз, но и в случае, если два положения имеют одинаковую
	высоту, выбрать то, у которого центр масс фигуры ниже.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Рассмотрим на примере, как таким способом можно расположить некоторый пятиугольник. На рис. <a href="#bl_principle">12</a> видно, что шестиугольник расположился своим центром масс к низу, выставив наверх ту часть, которая оставляет больше свободного места для расположения оставшихся фигур.
	
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Можно придумать множество дальнейших модификаций данного метода, например, сначала оценивать описывающий прямоугольник множества фигур и выбирать тот вариант расположения, при котором он меньше.
	
 <a id="tth_sEc6"></a><h2>
6.&nbsp;&nbsp;Генетические алгоритмы</h2>
	Таким же образом, как нейронные сети пытаются имитировать мощь мозга, эволюционные алгоритмы (ЭА) воспроизводят биологическую эволюцию. Например, природа создала сложную структуру человеческого мозга из простейших элементов, пользуясь лишь мощью эволюции и естественного отбора. Так же как естественный отбор действует на популяции животных, позволяя лучшим выжить и передать свои гены потомкам, так же и ЭА действует, например, на последовательности раскроя, нейронные сети, электрические контуры и так далее. Они определяют качество каждого элемента в популяции, позволяя
	лучшим выжить и убивая слабейших. Далее - очень важный шаг - они позволяют различным решениям «скрещиваться» между собой, порождая, возможно, более жизнеспособные
	решения.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Генетический алгоритм (ГА) - самый популярный из эволюционных алгоритмов. Он был изобретён Джоном Холландом в Университете Мичигана в 1975 году. По изначальной задумке, ГА использовал только бинарные числа, но для извлечения большей пользы будем пользоваться десятичными числами. Сам алгоритм состоит из нескольких частей [<a href="#McLeod" id="CITEMcLeod" class="tth_citation">5</a>]:
	
<ol type="1">
<li> Кодирование проблемы в виде генов.
<div class="p"><!----></div>
</li>

<li> Выведение первоначального поколения.
<div class="p"><!----></div>
</li>

<li> Вычисление оценок для индивидов.
<div class="p"><!----></div>
</li>

<li> Скрещивание.
<div class="p"><!----></div>
</li>

<li> Мутация.
<div class="p"><!----></div>
</li>
</ol>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Рассмотрим ГА на применительно к задаче раскроя [<a href="#China" id="CITEChina" class="tth_citation">6</a>].
	
     <a id="tth_sEc6.1"></a><h3>
6.1.&nbsp;&nbsp;Кодирование задачи</h3>
	Основываясь на предложенных ранее методах представления и перемещения фигур, можно заметить, что не имеет смысла включать в геном координаты положения и угол поворота так, как они будут вычислены при расположении последовательности. Достаточно кодировать лишь саму последовательность раскроя. Отметим, что для достижения результата, в геноме инидвида не должно быть повторов, соответственно каждый ген должен быть уникален. Таким образом индивидом будет являться - последовательность просто раскроя, ведь углы постановки и координаты будут восстановлены при расположении, а геном - порядковый номер фигуры в исходном наборе - это позволит избежать повторов.
	
     <a id="tth_sEc6.2"></a><h3>
6.2.&nbsp;&nbsp;Инициализация первого поколения</h3>
	Первое поколение индивидов оказывает огромное влияние на результат всего ГА. Чтобы получить неплохой первичный набор, можно расположить по порядку отсортированные по площади фигуры, а остальных индивидов первого поколения получить с помощьюмутации.
	
     <a id="tth_sEc6.3"></a><h3>
6.3.&nbsp;&nbsp;Оценка индивидов</h3>
	Оценку результата можно проводить различными способами. Можно, к примеру, ввести некоторую оценочную функцию. Рассматривая задачу раскроя, за оценку можно взять занятую фигурами площадь. Далеко необязательно использовать какой-то один фактор, например, если индивид I характеризуется парой (n, h), где n - число размещённых фигур, а h - высота раскроя, то можно взять за оценку данную пару. Тогда то, что индивид I<sub>1</sub> лучше, чем индивид I<sub>2</sub> можно записать через следующее отношение &#961;:
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
I<sub>1</sub>&nbsp;&#961;&nbsp;I<sub>2</sub>=(n<sub>1</sub> &gt; 2&#8743;(n<sub>1</sub>=n<sub>2</sub>&#8744;h<sub>1</sub> &lt; h<sub>2</sub>)).</td></tr></table>
</td><td width="1%">(6)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Тоже самое можно записать с помощью следующей функции оценки индивидов:
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
f(I)=n+h<sup>&#8722;1</sup>,</td></tr></table>
</td><td width="1%">(7)</td></tr></table>


	тогда достаточно сравнивать числовые значения функций. Выбранная функция будет принимать большее значение при лучшем варианте раскроя. Вообще говоря, можно использовать любую функцию, исходя из условий задачи.
	
     <a id="tth_sEc6.4"></a><h3>
6.4.&nbsp;&nbsp;Скрещивание</h3>
	Рассмотрим скрещивание на следующем примере:
	
<ol type="1">
<li> Выберем двух индивидов, например [5 2 3 7 6 1 4] и [4 6 2 1 3 5 7].
<div class="p"><!----></div>
</li>

<li> Случайным образом выберем часть первого родителя, которая перейдёт в потомка: [5
		2 (3 7) 6 1 4].
<div class="p"><!----></div>
</li>

<li> Удалим эти элементы из второго родителя: [4 6 2 1 (3) 5 (7)].
<div class="p"><!----></div>
</li>

<li> Первого потомка получим путём копирования генов второго родителя в первого: [4 6
		3 7 2 1 5].
<div class="p"><!----></div>
</li>

<li> Повторим действия 1-3, поменяв родителей местами.
<div class="p"><!----></div>
</li>

<li> Второго потомка получим путём копирования генов первого родителя во второго: [5
		3 2 1 7 6 4].
<div class="p"><!----></div>
</li>
</ol>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Из курса математического анализа известно, что функция может иметь некоторое количество точек экстремума. Минимальное значение может достигаться в нескольких различных точках, но при этом есть и экстремумы которы минимумом не являются. 
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	В процессе скрещивания стоит использовать не только самых лучших, индивидов но и достаточно хороших в целях избежания попадания на экстремумы, не являющиеся точками минимума локальные оптимумы. Данное явление называется преждевременной сходимостью или сходимостью к квазиоптимальному решению [<a href="#GA" id="CITEGA" class="tth_citation">7</a>] 
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	На рис. <a href="#not_solve">13</a>, для некоторой функции f:X&#8594; Y, продемонстрированы точки квазиоптимального и оптимального решения. На рисунке цифра 1 - квазиоптимальное решение, а 2 - оптимальное. 
	
	
     <a id="tth_sEc6.5"></a><h3>
6.5.&nbsp;&nbsp;Мутация</h3>
	Мутация происходит после скрещивания и применяется к новым индивидам, на самом деле можно применять и к появившимся ранее. В случае раскроя в процессе мутации меняются местами два гена в последовательности. Вероятность мутации должна быть не очень высокой, приблизительно 10%, также можно изменять экспериментально. Иногда можно переставлять не просто два гена, а целые части последовательности, но не стоит делать этого слишком часто.
	
     <a id="tth_sEc6.6"></a><h3>
6.6.&nbsp;&nbsp;Отбор</h3>
	Теперь, когда для каждого индивида вычислена оценка, можно провести отбор для создания нового поколения. Самый простой вариант - взять только те индивиды, у которых достаточно хорошая оценка. В классическом варианте генетического алгоритма, индивиды в новом поколении выбираются случайно, а вероятность попадания индивида в новое поколение будет пропорциональна его оценке. Например,
				
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
p<sub>i</sub> = f<sub>i</sub><sup>&#8722;1</sup></td><td nowrap="nowrap" align="center">
<span class="largerstill">&#8721;<br />
</span></td><td nowrap="nowrap">f<sub>k</sub>.</td></tr></table>
</td><td width="1%">(8)</td></tr></table>


	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	На самом деле, включать в новое поколение можно не только те индивиды, которые были выведены на данном шаге, но и те которые уже были ранее, ведь они могут быть не хуже чем те, что только что появились.
	
 <a id="tth_sEc7"></a><h2>
7.&nbsp;&nbsp;Заключение</h2>
	В результате было реализовано два метода раскроя. Один на основе фигур в виде многоугольникв, другой использует растровые матрицы. Первый показал свою полную несостоятельность. Он имеет огромную вычислительную сложность при очень низком качестве на реальных примерах. В дальнейшем развиваться будет только растровый метод. Он отлично подходит для фигур с большим количеством вершин и сложными формами.
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	Для наглядности результата, возьмём лист 1063&times;1063 мм. В раскройный план входят следующие наименования фигур:
	
<ol type="1">
<li> &lt;&lt;Олень&#62;&#62; - 5 штук, с шагом 15 градусов.
<div class="p"><!----></div>
</li>

<li> &lt;&lt;Обезьянка&#62;&#62; - 5 штук, с шагом 15 градусов.
<div class="p"><!----></div>
</li>

<li> &lt;&lt;Голубь&#62;&#62; - 5 штук, с шагом 15 градусов.
<div class="p"><!----></div>
</li>

<li> &lt;&lt;Лошадка&#62;&#62; - 5 штук, с шагом 15 градусов.
<div class="p"><!----></div>
</li>

<li> &lt;&lt;Ангелок&#62;&#62; - 5 штук, с шагом 15 градусов.
<div class="p"><!----></div>
</li>
</ol>
	
<div class="p"><!----></div>
<b>&nbsp;&nbsp;</b>
	За 10 итераций генетического алгоритма были достигнуты следующие результаты:
	
<ol type="1">
<li> Раскройный план полностью выполнен с использованием двух листов.
<div class="p"><!----></div>
</li>

<li> Первичная высота раскроя на первом листе - 298.3 мм, итоговая высота - 292.1 мм.
<div class="p"><!----></div>
</li>

<li> Первичная высота раскроя на втором листе - 172.2 мм, итоговая высота - 167.4 мм.
<div class="p"><!----></div>
</li>
</ol>
	Следует отметить, что для примера взят достаточно маленький лист. Экономия материала линейно возрастает с увеличением площади. Результаты можно увидеть на рис. <a href="#plane12">14</a>.
	
<div class="p"><!----></div>
<a id="tth_fIg1">
</a> 		<div style="text-align:center">		<a href="plane1">Figure</a>
		<a href="plane2">Figure</a>
		
<div style="text-align:center">Figure 1: Первый и второй раскройные листы</div>
		<a id="plane12">
</a>
	</div>
<div class="p"><!----></div>
	
<h2>References</h2>

<dl>
		 <dt><a href="#CITEDyckhoff" id="Dyckhoff">[1]</a></dt><dd> Dyckhoff H. A typology of cutting and packing problems // European Journal of Operational Research. № 44. 150-152 p.
		</dd>
 <dt><a href="#CITECantorovich" id="Cantorovich">[2]</a></dt><dd> Залгаллер В. А., Канторович Л. В. Рациональный раскрой промышленных материалов. Новосибирск: Наука, 1971.
		</dd>
 <dt><a href="#CITENikitenkov" id="Nikitenkov">[3]</a></dt><dd> Никитенков В.Л., Холопов А.В. Задачи линейного программирования и методы их решения. Сыктывкар, 2008. 143 с.
		</dd>
 <dt><a href="#CITEBenell_Olivera" id="Benell_Olivera">[4]</a></dt><dd> Benell A. J., Olivera F. J. The geometry of nesting problems: A tutorial // European Journal of Operational Research. 2008. № 184. 399-402 p.
		</dd>
 <dt><a href="#CITEMcLeod" id="McLeod">[5]</a></dt><dd> MacLeod C. An Introduction to Practical Neural Networks and Genetic Algorithms For Engineers and Scientists. 85 p.
		</dd>
 <dt><a href="#CITEChina" id="China">[6]</a></dt><dd> He Y., Liu H. Algorithm for 2D irregular-shaped nesting problem based on the NFP algorithm and lowest gravity-center principle // Journal of Zhejiang University. 2006. № 7. 571 - 574 p.
		</dd>
 <dt><a href="#CITEGA" id="GA">[7]</a></dt><dd> Панченко Т. В. Генетические Алгоритмs; под ред. Ю. Ю. Тарасевича. Издательский дом &lt;&lt;Астраханский университет&#62;&#62;. 2007. 16 с.</dd>
</dl>

<br /><br /><hr /><small>File translated from
T<sub><span class="small">E</span></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><span class="small">T</span></sub>H</a>,
version 4.08.<br />On 20 Sep 2016, 07:32.</small>
</html>
