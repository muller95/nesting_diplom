% Выбор класса документа
\documentclass[14pt]{extarticle}
% Чтобы можно было использовать русские буквы в формулах ,
%но в случае использования предупреждать об этом
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{layout}
\usepackage[height=25cm, a4paper, hmargin={3cm,2cm}]{geometry}

% Выбор внутренней TEX−кодировки
\usepackage[TS1,T2A]{fontenc}
\usepackage [utf8x] {inputenc}
\usepackage{amssymb}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{fancyhdr}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\usepackage{listings}
\usepackage{afterpage}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{setspace}
\onehalfspacing
\usepackage[labelsep=period]{caption}
\lstset{language=C,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
keywordstyle=\color{bluekeywords}\bfseries,
stringstyle=\color{redstrings},
basicstyle=\ttfamily,
extendedchars=\true,
inputencoding=utf8x
}
\usepackage [english , russian] {babel}
\usepackage{etoolbox}
\addto\captionsrussian{\def\contentsname{Содержание}}
\addto\captionsrussian{\def\bibname{Список литературы}}
\renewcommand{\labelitemi}{---}
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}.}
% Начинать первый параграф раздела следует с красной строки
\usepackage {indentfirst}
% Конец преамбулы и начало текста
\begin{document}
	\begin{flushright}
		\textbf{Алгоритм для раскроя двумерного материала}\\
		\textit{\small Мельников Вадим Андреевич,\\ Сыткывкарский государственный университет им. Питирима Сорокина,\\ г. Сыктывкар.}
	\end{flushright}
	\paragraph{}
	\textbf{Аннтоция.} Данная сататья посвящена вопросам резки материала на заготовки неправильной формы в двумерном. Были рассмотрены основные вопросы связанные с представлением геометрической информации, методами отыскания оптимальной раскройной последовательности и оптимизацией алгоритма.
	\paragraph{}
	\textbf{Ключевые слова:} раскрой, генетические алгоритмы, двумерное пространство.
	\section{Введение в задачу раскроя материала}
	Экономия материала представляет собой сложную и важную проблему, с которой
	часто приходится встречаться на различных производствах, при резке различных материалов на: листы металла, стекла или дерева, трубы, профильный прокат, изделия сложной формы. Для её решения необходимо максимизировать использование материала, из которого вырезаются заготовки, что по сути и является рациональным раскроем материала. Максимизация использования материалов позволяет достичь большой экономии денежных средств.
	\paragraph{}
	На самом деле, задача раскроя является NP-полной даже для прямоугольников. Для
	фигур неправильной формы геометрическая сложность увеличивает количество совершаемых вычислений, поэтому применяются различные эвристические методы решения задачи.
	\section{Основные характеристика задач раскроя}
	Прежде чем приступать к рассмотрению алгоритмов решения задачи раскроя, следует рассмотреть характеристики, влияющие на то, как будет выглядеть итоговый алгоритм решения. В статье \cite{Dyckhoff} Harald Dyckhoff приводит достаточно полное описание характеристик задач раскроя.
	\subsection{Пространственные характеристики}
	Основная характеристика раскроя --- количество измерений:
	\begin{itemize}
		\item раскрой в одномерном пространстве;
		\item раскрой в двумерном пространстве;
		\item раскрой в трёхмерном пространстве.
	\end{itemize}
	\paragraph{}
	Например загрузка поддонов является задачей в двумерном пространстве. В отличие от 	задач в двух и более измерениях, задача в одномерном пространстве имеет явное решение. Достаточно подробно данная задача описывается в книге \cite{Cantorovich} Канторовича-Залгаллера --- <<Рациональный раскрой промышленных материалов>>. Так же в данной книге можно найти методы решения задач двумерного раскроя для случая прямоугольнных заготовок.
	\subsection{Количественные характеристики}
	Другая важная характеристика --- количественная. В задаче раскроя необходимо
	некоторым образом измерять количественные и качественные характеристики фигур.
	Например, площадь, длина и ширина фигур. Или количество уже расположенных фигур. Тут можно рассмотреть два варианта:
	\begin{itemize}
		\item дискретное измерение с помощью, например, натуральных и целых чисел;
		\item дробное измерение на основе вещественных чисел.
	\end{itemize}
	\paragraph{}
	Первый вариант позволяет нам подсчитывать количество изделий, уже расположенных
	на материале, а с помощью второго можно измерять различные характеристики фигур, 	такие как площадь, длина и ширина.
	\subsection{Геометрические характеристики}
	Не малую роль играют в раскрое сами фигуры, которые необходимо расположить
	на плоскости. В пространстве фигуры однозначно определяются с помощью следующих
	свойств:
	\begin{itemize}
		\item формой;
		\item размером;
		\item ориентацией;
		\item правильной или неправильной формой.
	\end{itemize}
	\subsection{Характеристики по ограничениям на результат}
	По ограничениям на результат можно выделить четыре основные группы:
	\begin{itemize}
		\item  минимальное расстояние между объектами;
		\item ориентация фигур относительно друг друга;
		\item ограничение на количество фигур;
		\item ограничение на количество совершаемых <<резов>>.
	\end{itemize}
	\paragraph{}
	Автор выделяет ещё несколько групп по различным признакам, но данные являются
	основными.
	\section{Постановка задачи}
	Прежде чем переходить к алгоритмам, применяемым для решения задачи раскроя, следует рассмотреть математическую постановку задачи. Задача ставится по аналогии с задачей раскроя в одномерном пространстве \cite{Nikitenkov}.
	\paragraph{}
	Имеется сырьё площади $S$, на котором неоьходимо расставить заготовки $M$ различных типов. Площади заготовок задаются вектором $s[M]$, а количество заготовок каждого типа задаётся вектором $b[M]$.
	\paragraph{}
	Пусть матрица $A[M, N]$ --- целочисленная матрица всех потенциально возможных способов раскроя одной единицы сырья, $|N|=n$ --- число таких способов. Потенциально возможный способ раскроя --- столбец матрицы $A[M, j], j\in 1:N$, удовлетворяющий условию:
	\paragraph{}
	\begin{equation}
		s[M]\cdot A[M,j]\leq S.
	\end{equation}
	\paragraph{}
	Пусть $x[M]$ --- искомый вектор, являющийся некоторым столбцом матрицы $A$. Тогда задача минимизации суммарных отходов сырья запишится следующим образом:
	\begin{equation}
		\begin{cases}
			f = S - x^T[M]\cdot s[M] \to \min \\
			x[M] \leq b[M]\\
			S - x^T[M]\cdot s[M] \geq 0 \\
			x[M] \geq 0
		\end{cases}
	\end{equation}
	\paragraph{}
	Важной особенностью задачи раскроя в двумерном пространстве является то, что не каждый столбец матрицы $A$ удовлетворяющий заданным условиям является реальным решением. Данный факт объясняется произвольностью форм заготовок, поэтому нельзя одназначно утверждать, что если заданные условия выполнены для некоторой последовательности, то эта последовательность является решением.
	\paragraph{}
	Из сказанного выше следует нелинейность задачи и то, что решение задачи может быть не только на границе многогранника, заданного условиями. Таким образом, необходимо отыскивать последовательность с помощью некоторого <<оптимизированного>> перебора. Также заданные условия никак не определяют координаты расстановки заготовок на единице сырья. Методы для решения данныъ проблем и будут описываться в дальнейшем. 
	\section{Методы представления фигур для раскроя}
	Самым видимым атрибутом задач раскроя и тем, с чем сразу сталкиваются исследователи в данной области --- геометрическое представление фигур. Решение о том, 	как представлять фигуры, оказывает решающее значение на дальнейшую разработку системы.
	\subsection{Методы перемещения фигур}
	Прежде чем перейти к рассмотрению методов представления фигур, следует осветить важный вопрос, обычно опускаемый в литературе связанной с раскроем: <<Каким 	образом перемещать фигуры относительно друг друга?>>.
	\paragraph{}
	Предположим, что мы уже некоторым образом расположили первую фигуру. Она распологается всегда в левом нижнем углу, как на рис. \ref{first_placed}. Для удобства, границы контейнера изображать не будем. Условимся, что вторая фигура в конечном расположении будет закрашена серым цветом.
	\input{first_placed.tex}
	\paragraph{}
	Самый первый метод, который будет интуитивно понятен всем — <<лестничный>> или же	<<тетрисный>>. Его суть заключается в том, что мы двигаем фигуру вниз до первого столкновения с другой, потом также влево, потом опять вниз, и так далее пока фигура не перестанет смещаться. Рассмотрим на примере, как <<тетрисный>> способ расположит следующую фигуру. На рис. \ref{second_tetris} видно, что фигура перемещается слева направо с некоторым шагом по оси $x$ и в итоге находит углебление внутри другой фигуры.
	\input{second_tetris.tex}
	\paragraph{}
	Более сложный метод — «метод сквозного прохода». Его основная идея заключается в том, что фигуру просто перемещают сквозь остальные и ищут подходящее ей место. Как 	видно на рис. \ref{second_through}, данный метод нашёл закрытую полость, до которой предыдущий способ дойти не смог.
	\input{second_through.tex}
	\paragraph{}
	Самый сложный метод --- движение вдоль контура. Под контуром, в данном случае,
	подразумевается обновляемый контейнер. Изначально имеется некоторый контур пустого контейнера, затем в него добавляются одна за одной фигуры, и контур после расположения каждой из них изменяется. Таким образом, фигура движется вдоль контура контейнера, при нахождении подходящего места необходимо обновить контур с учетом расположения новой фигуры. На данный момент этот метод будет оставлен без особого внимания. Для его реализации необходимо создать цепь (растровую или же векторную) вдоль которой будет перемещаться фигура. Большую сложность, представляет в данном случае вопрос о выборе точки, относительно которой идёт движение.
	\subsection{Представление фигур в виде многоугольников}
	Представление фигур в виде многоугольников даёт хорошую точность аппроксимации. В таком представлении объем информации пропорционален числу вершин и не зависит от размера фигуры. Полигональное представление является первичным для фигур, а на его основе уже можно построить растровое представление, которое будет описано ниже.
	\paragraph{}
	Полигональный метод хоть и даёт высокую точность представления, но имеет очень высокую вычислительную сложность --- $\mathrm{O}(e^n)$, где $n$ --- число вершин фигуры.
	\paragraph{}
	Для того, чтобы проверить нет ли пересечений между какими-либо фигурами нужно
	выполнить следующий набор тестов \cite{Benell_Olivera}:
	\begin{enumerate}
		\item Проверить пересекаются ли описывающие прямоугольники фигур, если нет, то и фигуры не пересекаются, иначе перейти к следующему тесту.
		\item Для каждой пары рёбер проверить, пересекаются ли их описывающие прямоугольники.
		\item Проверить, пересекаются ли рёбра.
		\item Проверить, лежат ли какие-либо вершины одного полигона, внутри другого.
	\end{enumerate}
	\input{polygon.tex}
	\paragraph{}
	Проверка на пересечения текущей фигуры с ранее расположенными может выполняться различными способами. Первый вариант --- через уравнение прямой с угловым коэффициентом. Этот метод для данной задачи будет излишним, ведь кроме проверки на пересечение двух отрезков, будут найдены точка пересечения и угловой коэффициент $k$ данной прямой. Также придётся проверять специальные случаи, когда прямые параллельны, когда они направлены вертикально вверх. Лучше использовать метод проверки на основе псевдоскалярного произведения, ведь тогда сильно снизится вычислительная нагрузка. Данный метод подробно рассматривается в задачах вычислительной геометрии.
	\paragraph{}
	Для перемещения фигуры подходят только алгоритмы <<тетрисного>> движения. Применять «сквозное движение» мы не можем, так, как тогда придется постоянно проверять, не попала ли она внутрь другой, что в случае многоугольников сделать достаточно сложно. Для этого необходимо применять метод <<трассировки луча>> или приближённо считать комплексный интеграл, пользуясь интегральной формулой Коши.
	\paragraph{}
	Алгоритмы с представлением фигур в виде полигонов хорошо подходят для прямоугольников и несложных многоугольников с числом вершин до сотни. Для более сложных сильно возрастает время вычисления пересечений.
	\paragraph{}
	Проблема данного метода состоит в сложности обработки контура. Построить эквидистантный (равноудалённый во всех точках от исходного) контур, чтобы задать зазор --- не
	такая уж лёгкая задача. Отделить внешний контур от внутренних тоже несколько сложнее,
	ведь контур может состоять из нескольких раздельных кривых, пусть и образующих в
	сумме одну замкнутую кривую.
	\subsection{Представление фигур в виде растровых матриц}
	Растровый метод, позволяет упростить геометрическую сложность фигуры и без дополнительных оптимизаций снизить сложность вычислений до $\mathrm{O}(n^2)$.
	\paragraph{}
	Растровые методы предлагают разделить непрерывный раскройный лист на дискретные части, упрощая сложную геометрическую информацию до представления матрицей. Под матрицей будем понимать некоторое представление растра, в котором отмечены занятые и свободные места. Различные авторы предлагают различные методы представления.
	\paragraph{}
	Самый простой метод представления --- это $1$ для занятого деталью места и $0$ для свободного. Раскраиваемый материал в данном случае представляется аналогично. На рис. \ref{first_rastr}
	можно увидеть первичный вариант растрового представления \cite{Benell_Olivera}. В данном случае занятые области отмечены серым цветом.
	\input{first_rastr.tex}
	\paragraph{}
	Растровый способ не является первичным, он строится из фигуры, представленной многоугольником.
	Поэтому нельзя сразу говорить какие места заняты, а какие нет, ведь на входе имеется простое наложение многоугольника на растровую матрицу, что можно увидеть на рис. \ref{fig_on_rastr}.
	Рассмотрим возможный алгоритм закраски занятых областей:
	\begin{enumerate}
		\item На первом шаге имеется исходный многоугольник. Выберем любое его ребро.
		\item Так как каждое ребро задается координатами $(x_1 , y_1 ) и (x_2 , y_2 )$, то на втором шаге можно получить уравнение прямой с угловым коэффициентом, которая содержит данный
		отрезок. Для определённости будем считать, что $y_1 \leq y_2$.
		\item Зададим множество $A=\{a_0, a_1, a_2, ..., a_{n-1}, a_n\}$, где $a_0=y_1$, а $a_n = y_2$. Остальные элементы являются целыми числами из интервала $(y_1, y_2)$.  
		\item Теперь, для каждой пары чисел $\{a_i, a_{i+1}\},\ i = 0:n-1$, из имеющегося уравнения прямой $y=kx+b$, вычислим $x_i$ и $x_{i+1}$.
		\item Вычислив, все необходимые координаты, можно отметить занятыми, все клетки на отрезке заданном координатами $(x_i, a_i),\ (x_{i+1}, a_i)$.
	\end{enumerate}
	\paragraph{}
	Алгоритм рассматривает переход от отрезка к растру. Для перехода от многоугольника к растру достаточно повторить описанный алгоритм для всех его ребёр. В итоге получится то, что изображено на рис. \ref{first_rastr}.
	\input{fig_on_rastr.tex}
	\paragraph{}
	Операция проверки на пересечения с другими фигурами, при текущем расположении в координате $(x, y)$ фигуры с шириной равной $w$ и высотой $h$, не требует никаких сложных действий. Производится простое суммирование по следующей формуле:
	\begin{equation}
		\label{simple_sum}
		S = \sum_{i=1}^{h}\sum_{j=1}^{w}p_{i+y, j+x}f_{i,j} 
	\end{equation}
	\paragraph{}
	В данном случае, $p_{i+y,j+x}$ --- значение в матрице раскройной плоскости со смещением на координату $(x, y)$, а $f_{i,j}$ --- значение в матрице фигуры. В случае если значение $S > 0$, то есть пересечение с некоторой фигурой, иначе его нет.
	\paragraph{}
	Как видно на рис. \ref{first_rastr}, не все области внутри фигуры отмечены как занятые. В таком случае, некоторые фигуры могут попасть внутрь других, что будет являться ошибкой. Данная
	проблема может быть решена различными способами. Самый простой способ --- <<залить>> всё, что находится внутри внешнего конутура, отбрасывая пустоты внутри фигуры. Такой метод принесёт большие потери материала.
	\paragraph{}
	Рассмотрим метод, позволяющий учитывать пустые места внутри фигур. Для начала необходимо отделить внешний контур фигуры:
	\begin{enumerate}
		\item Примем за текущую самую левую занятую точку с наименьшей ординатой.
		\item  Отметим цифрой $3$ (на изображениях будет отмечаться диагональной штриховкой) текущую точку.
		\item Рассмотрим всех соседей текущей точки. Если есть соседняя точка, отмеченная цифрой $1$, переходим в данную точку и возвращаемся на второй шаг. Если текущая точка --- исходная, то закончить алгоритм, иначе повторить текущий шаг.
	\end{enumerate}
	\paragraph{}
	Результат работы алгоритма можно увидеть на рис. \ref{result_contour}.
	\input{result_contour.tex}
	\paragraph{}
	После отделения внешнего контура, необходимо отметить занятым, всё место между внешним контуром и контурами второго уровня. Это можно сделать следующим образом:
	\begin{enumerate}
		\item Первым шагом необходимо сохранить точки контура в отдельный массив и отметить их, как свободные на растровой матрице.
		\item Далее, выполняется <<заливка>>. В процессе <<заливки>>, свободные клетки отмечаются как временно занятые цифрой $2$ (на изображениях будет изображаться перекрёстной штриховкой). Результат первых двух шагов приведён на рис. \ref{12fill_result}.
		\item\label{3fill_step} Третьим шагом инвертируем <<заливку>>. Для этого необходимо все клетки, отмеченные цифрой $2$, отметить цифрой $0$. Свободные клетки необходимо отметить как временно занятые.
		Занятые клетки не затрагиваются. После этого можно вернуть на растровой матрице контур фигуры. Результат данного шага приведён на рис. \ref{3fill_result}.
		\item После этого опять выполняется <<заливка>>. Результат четвёртого шага приведён на рис. \ref{4fill_result};
		\item Последним шагом опять выполняется инверсия <<заливки>> по тем же правилам, что и на третьем шаге. Результат работы алгоритма приведён на рис. \ref{fill_result}.
	\end{enumerate}
	\input{12fill_result.tex}
	\input{3fill_result.tex}
	\input{4fill_result.tex}
	\input{fill_result.tex}
	\subsection{Условия корректности данных}
	Для корректности работы описанных выше алгоритмов и некоторых дальнейших выкладок необходимо ввести условия корректности.

	\paragraph{}
	Фигура является корректной, если выполняются следующие условия:
	\begin{enumerate}
		\item Фигура имеет замкнутый внешний контур.
		\item Уровень вложенности контуров не более первого. Это означает, что контура могут вкладываться только во внешний контур, то есть если контур является вложенным во внешний, то в него уже не может быть вложен контур.
		\item Вложенные контуры не должны иметь пересечений друг с другом.
		\item Ни один из контуров не должен иметь самопересечений.
	\end{enumerate} 
	\paragraph{}
	Несоблюдение приведённых выше условий может привести к непредсказуемым результатам работы алгоритма.
	\subsection{Уменьшение сложности до линейной}
	Для корректности дальнейших действий, введём условие, что движение фигур по плоскости материала происходит строго построчно. Из данного утверждения следует тот факт, что если фигура пересекает занятое другой фигурой место, то, хотя бы в одной из точек, пересечение будет лежать на контуре текущей фигуры.
	\paragraph{}
	Тогда можно снизить сложность поиска пересечений до $\mathrm{O}(n)$, где $n$~--- число точек, входящих в контур. Такой способ поиска пересечений является суммированием по следующей формуле:
	\begin{equation}
		S=\sum_{(i,j)\in\Gamma}p_{i+y,j+x}.
	\end{equation}
	\paragraph{}
	Данная формула аналогична формуле \ref{simple_sum},  но суммирование проходит только по тем точкам $(j, i)$, которые входят во внешний контур $\Gamma$.
	\section{Принципы позиционирования фигур}
	Определившись с представлением фигур и методом их перемещения, разработчику необходимо решить, каким образом производить позиционирование. Первое с чего стоит начать --- это поворот фигур. Некоторые авторы предлагают применять изменение угла методом дихотомии, что по сути является бинарным поиском. Но тут возникает большая проблема. Бинарный поиск работает на отсортированном множестве, а контур фигуры таковым не является, поэтому поворот следует выполнять просто с дискретным шагом изменения угла.
	\paragraph{}
	После того как фигура уже лежит где-то на плоскости, её положение надо оценить.
	Очень часто применяют принцип левого нижнего угла (ЛН-принцип). Так-как фигуры
	имеют сложный контур, можно предложить следующее улучшение данного метода. Пользуясь тем, что точки входящие контур известны, можно найти его центр масс по следующей формуле:
	\begin{equation}
		p_g=\sum_{(i,j)\in\Gamma}\frac{p_{i, j}}{n},
	\end{equation}
	где $p_{i, j}$ --- это точка входящая в контур $\Gamma$. Теперь можно не только пытаться расположить
	фигуру максимально влево и вниз, но и в случае, если два положения имеют одинаковую
	высоту, выбрать то, у которого центр масс фигуры ниже.
	\paragraph{}
	Рассмотрим на примере, как таким способом можно расположить некоторый пятиугольник. На рис. \ref{bl_principle} видно, что пятиугольник расположился своим центром масс к низу, выставив наверх ту часть, которая оставляет больше свободного места для расположения оставшихся фигур.
	\input{bl_principle.tex}
	\paragraph{}
	Можно придумать множество дальнейших модификаций данного метода, например, сначала оценивать описывающий прямоугольник множества фигур и выбирать тот вариант расположения, при котором он меньше.
	\section{Генетические алгоритмы}
	Таким же образом, как нейронные сети пытаются имитировать мощь мозга, эволюционные алгоритмы (ЭА) воспроизводят биологическую эволюцию. Например, природа создала сложную структуру человеческого мозга из простейших элементов, пользуясь лишь мощью эволюции и естественного отбора. Так же как естественный отбор действует на популяции животных, позволяя лучшим выжить и передать свои гены потомкам, так же и ЭА действует, например, на последовательности раскроя, нейронные сети, электрические контуры и так далее. Они определяют качество каждого элемента в популяции, позволяя
	лучшим выжить и убивая слабейших. Далее --- очень важный шаг --- они позволяют различным решениям «скрещиваться» между собой, порождая, возможно, более жизнеспособные
	решения.
	\paragraph{}
	Генетический алгоритм (ГА) --- самый популярный из эволюционных алгоритмов. Он был изобретён Джоном Холландом в Университете Мичигана в 1975 году. По изначальной задумке, ГА использовал только бинарные числа, но для извлечения большей пользы будем пользоваться десятичными числами. Сам алгоритм состоит из нескольких частей \cite{McLeod}:
	\begin{enumerate}
		\item Кодирование проблемы в виде генов.
		\item Выведение первоначального поколения.
		\item Вычисление оценок для индивидов.
		\item Скрещивание.
		\item Мутация.
	\end{enumerate}
	\paragraph{}
	Рассмотрим ГА на применительно к задаче раскроя \cite{China}.
	\subsection{Кодирование задачи}
	Основываясь на предложенных ранее методах представления и перемещения фигур, можно заметить, что не имеет смысла включать в геном координаты положения и угол поворота так, как они будут вычислены при расположении последовательности. Достаточно кодировать лишь саму последовательность раскроя. Отметим, что для достижения результата, в геноме инидвида не должно быть повторов, соответственно каждый ген должен быть уникален. Таким образом индивидом будет являться --- последовательность просто раскроя, ведь углы постановки и координаты будут восстановлены при расположении, а геном --- порядковый номер фигуры в исходном наборе --- это позволит избежать повторов.
	\subsection{Инициализация первого поколения}
	Первое поколение индивидов оказывает огромное влияние на результат всего ГА. Чтобы получить неплохой первичный набор, можно расположить по порядку отсортированные по площади фигуры, а остальных индивидов первого поколения получить с помощью мутации.
	\subsection{Оценка индивидов}
	Оценку результата можно проводить различными способами. Можно, к примеру, ввести некоторую оценочную функцию. Рассматривая задачу раскроя, за оценку можно взять занятую фигурами площадь. Далеко необязательно использовать какой-то один фактор, например, если индивид $I$ характеризуется парой $(n, h)$, где $n$ --- число размещённых фигур, а $h$ --- высота раскроя, то можно взять за оценку данную пару. Тогда то, что индивид $I_1$ лучше, чем индивид $I_2$ можно записать через следующее отношение $\mathrm{\rho}$:
	\begin{equation}
		I_1~\rho~I_2=(n_1>n_2\lor(n_1=n_2\land h_1<h_2)).
	\end{equation}
	\paragraph{}
	Тоже самое можно записать с помощью следующей функции оценки индивидов:
	\begin{equation}
		f(I)=n+h^{-1},
	\end{equation}
	тогда достаточно сравнивать числовые значения функций. Выбранная функция будет принимать большее значение при лучшем варианте раскроя. Вообще говоря, можно использовать любую функцию, исходя из условий задачи.
	\subsection{Скрещивание}
	Рассмотрим скрещивание на следующем примере:
	\begin{enumerate}
		\item Выберем двух индивидов, например [5 2 3 7 6 1 4] и [4 6 2 1 3 5 7].
		\item Случайным образом выберем часть первого родителя, которая перейдёт в потомка: [5
		2 (3 7) 6 1 4].
		\item Удалим эти элементы из второго родителя: [4 6 2 1 (3) 5 (7)].
		\item Первого потомка получим путём копирования генов второго родителя в первого: [4 6
		3 7 2 1 5].
		\item Повторим действия 1---3, поменяв родителей местами.
		\item Второго потомка получим путём копирования генов первого родителя во второго: [5
		3 2 1 7 6 4].
	\end{enumerate}
	\paragraph{}
	Из курса математического анализа известно, что функция может иметь некоторое количество точек экстремума. Минимальное значение может достигаться в нескольких различных точках, но при этом есть и экстремумы которы минимумом не являются. 
	\paragraph{}
	В процессе скрещивания стоит использовать не только самых лучших, индивидов но и достаточно хороших в целях избежания попадания на экстремумы, не являющиеся точками минимума локальные оптимумы. Данное явление называется преждевременной сходимостью или сходимостью к квазиоптимальному решению \cite{GA}.
	\paragraph{}
	На рис. \ref{not_solve}, для некоторой функции $f:X\to Y$, продемонстрированы точки квазиоптимального и оптимального решения. На рисунке цифра 1 --- квазиоптимальное решение, а 2 --- оптимальное. 
	\input{not_solve.tex}
	\subsection{Мутация}
	Мутация происходит после скрещивания и применяется к новым индивидам, на самом деле можно применять и к появившимся ранее. В случае раскроя в процессе мутации меняются местами два гена в последовательности. Вероятность мутации должна быть не очень высокой, приблизительно 10\%, также можно изменять экспериментально. Иногда можно переставлять не просто два гена, а целые части последовательности, но не стоит делать этого слишком часто.
	\subsection{Отбор}
	Теперь, когда для каждого индивида вычислена оценка, можно провести отбор для создания нового поколения. Самый простой вариант --- взять только те индивиды, у которых достаточно хорошая оценка. В классическом варианте генетического алгоритма, индивиды в новом поколении выбираются случайно, а вероятность попадания индивида в новое поколение будет пропорциональна его оценке. Например,
	\begin{equation}
		p_i = f_i^{-1}\sum f_k.
	\end{equation}
	\paragraph{}
	На самом деле, включать в новое поколение можно не только те индивиды, которые были выведены на данном шаге, но и те которые уже были ранее, ведь они могут быть не хуже чем те, что только что появились.
	\section{Заключение}
	В результате было реализовано два метода раскроя. Один на основе фигур в виде многоугольников, другой использует растровые матрицы. Первый показал свою полную несостоятельность. Он имеет огромную вычислительную сложность при очень низком качестве на реальных примерах. В дальнейшем развиваться будет только растровый метод. Он отлично подходит для фигур с большим количеством вершин и сложными формами.
	\paragraph{}
	Для наглядности результата, возьмём лист $1063\times1063$ мм. В раскройный план входят следующие наименования фигур:
	\begin{enumerate}
		\item <<Олень>> --- 5 штук, с шагом 15 градусов.
		\item <<Обезьянка>> --- 5 штук, с шагом 15 градусов.
		\item <<Голубь>> --- 5 штук, с шагом 15 градусов.
		\item <<Лошадка>> --- 5 штук, с шагом 15 градусов.
		\item <<Ангелок>> --- 5 штук, с шагом 15 градусов.
	\end{enumerate}
	\paragraph{}
	За $10$ итераций генетического алгоритма были достигнуты следующие результаты:
	\begin{enumerate}
		\item Раскройный план полностью выполнен с использованием двух листов.
		\item Первичная высота раскроя на первом листе --- $298.3$ мм, итоговая высота --- $292.1$ мм.
		\item Первичная высота раскроя на втором листе --- $172.2$ мм, итоговая высота --- $167.4$ мм.
	\end{enumerate}
	\paragraph{}
	Следует отметить, что для примера взят достаточно маленький лист. Экономия материала линейно возрастает с увеличением площади. Результаты можно увидеть на рис. \ref{plane12}.
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.18]{plane1}
		\includegraphics[scale=0.18]{plane2}
		\caption{Первый и второй раскройные листы}
		\label{plane12}
	\end{figure}
	\begin{thebibliography}{1}
		\bibitem{Dyckhoff} Dyckhoff H. A typology of cutting and packing problems // European Journal of Operational Research. № 44. 150---152 p.
		\bibitem{Cantorovich} Залгаллер В. А., Канторович Л. В. Рациональный раскрой промышленных материалов. Новосибирск: Наука, 1971.
		\bibitem{Nikitenkov} Никитенков В.Л., Холопов А.В. Задачи линейного программирования и методы их решения. Сыктывкар, 2008. 143 с.
		\bibitem{Benell_Olivera} Benell A. J., Olivera F. J. The geometry of nesting problems: A tutorial // European Journal of Operational Research. 2008. № 184. 399---402 p.
		\bibitem{McLeod} MacLeod C. An Introduction to Practical Neural Networks and Genetic Algorithms For Engineers and Scientists. 85 p.
		\bibitem{China} He Y., Liu H. Algorithm for 2D irregular-shaped nesting problem based on the NFP algorithm and lowest gravity-center principle // Journal of Zhejiang University. 2006. № 7. 571 --- 574 p.
		\bibitem{GA} Панченко Т. В. Генетические Алгоритмs; под ред. Ю. Ю. Тарасевича. Издательский дом <<Астраханский университет>>. 2007. 16 с.
	\end{thebibliography}
\end{document}